<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="module" src="js-lite/watcher.js"></script>
<script type="module">
    import Watcher from './js-lite/watcher.js';
    import {observe,} from './js-lite/observer.js';
    import {setInPath,} from './js-lite/util.js';

    //TODO watch 的 oldValue 有点问题, 一直跟原来的值一样, 代码里运行有问题, console 里运行就正常
    class DataStore {
        constructor(value) {
            const data = {};
            if (value) {
                Object.assign(data, value);
            }
            // 为了满足 watcher 的需求
            Object.defineProperty(data, '_watchers', {
                configurable: false,    // 不可重定义
                enumerable: false,      // 不可被遍历
                writable: true,         // 可修改?
                value: [],
            });

            observe(data, true);

            Object.defineProperty(this, '_data', {
                configurable: false,    // 不可重定义
                enumerable: false,      // 不可被遍历
                writable: true,         // 可修改?
                value: data,
            });

            // 数据代理
            // 实现 vm.xxx -> vm._data.xxx
            Object.keys(data).forEach(key => this._proxyData(key));
        }

        _proxyData (key, setter, getter) {
            setter = setter ||
                Object.defineProperty(this, key, {
                    configurable: false,
                    enumerable: true,
                    get() {
                        return this._data[key];
                    },
                    set(newVal) {
                        this._data[key] = newVal;
                        // // 如果以前存在 key 值的话, 在初始化的 observe 里应该就已经监听过了
                        // let hasBefore = !!this._data[key];
                        // if (!hasBefore) {
                        //     //TODO 是不是应该还要再往根树的监听依赖上加一下
                        //     observe(newVal);
                        // }
                    },
                });
        }

        watch(key, cb) {
            new Watcher(this._data, key, cb, {
                user: true,
                deep: true,
            });
        }

        setIn(path, value) {
            const segments = setInPath(this, path, value);
            // 有返回值就是成功了, 这时候重新建立监控
            if (segments) {
                // 从根往下搜索没有 ob 过的对象, 找到第一个就直接开始监控
                let target = this._data;
                for (let i = 0; i < segments.length && target && target.__ob__; ++i) {
                    //TODO 如果这个对象有 set 和 get 属性, 很可能就会被忽略了
                    const property = Object.getOwnPropertyDescriptor(target, segments[i]);
                    if (!property || !property.get || !property.set) {
                        break;
                    }
                    target = target[segments[i]];
                }
                // 重新进行监控
                if (target && target.__ob__) {
                    target.__ob__.supplement();
                    // 现在需要再进行 watcher 的重放
                    if (this._data && Array.isArray(this._data._watchers)) {
                        this._data._watchers.forEach(item => {
                            item.value = item.get();
                        });
                    }
                    //TODO 这个地方需要触发一下对应对象的 notify 接口

                }
            }
        }
    }

    var ds = new DataStore({
        obj: {
            a: 3
        },
        a: 1,
        b: 2,
    });

    console.log(ds);

    window.ds = ds;

    ds.watch('a', (...args) => console.log('a', ...args));
    ds.watch('obj', (...args) => console.log('obj', ...args));
    ds.watch('obj.a', (...args) => console.log('obj.a', ...args));
    ds.watch('obj.b', (...args) => console.log('obj.b', ...args));
    ds.watch('obj.c', (...args) => console.log('obj.c', ...args));

    ds.obj.a = 1;
    ds.obj.b = 3;
    ds.setIn('obj.b', 4);
    ds.obj.b = 5;
    ds.setIn('obj.c', 4);
</script>
</body>
</html>